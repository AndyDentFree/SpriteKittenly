//
//  ReplayKitRecorder.swift
//  VidExies
//
//  Created by Andy Dent on 18/3/2025.
// generated by ChatGPT 03-mini-high
//


import ReplayKit
import AVFoundation
import SwiftUI

// manages state of recording
class ReplayKitRecorder: NSObject {
    private var assetWriter: AVAssetWriter?
    private var videoInput: AVAssetWriterInput?
    private var audioInput: AVAssetWriterInput?
    private var sessionAtSourceTime: CMTime?
    private var isSimpleCapture = false
    public private(set) var filesCreated = [URL]()  // not updated when have ReplayKit just to in-memory sample

    func createVideoFileURL(prefix: String) -> URL? {
        let fileManager = FileManager.default
        
        // Get the documents directory URL.
        guard let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }
        
        // Create a unique file name using the current date and time.
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd_HHmmss"
        let timestamp = formatter.string(from: Date())
        let fileName = "\(prefix)_\(timestamp).mp4"
        
        // Append the file name to the documents directory.
        let fileURL = documentsURL.appendingPathComponent(fileName)
        return fileURL
    }


    /// Starts recording to the given file URL., no Audio
    func startRecording(prefix: String) {
        guard let fileURL = createVideoFileURL(prefix: prefix) else {
            print("Error getting file with prefix: \(prefix)")
            return
        }
        isSimpleCapture = false
        // Create an AVAssetWriter for an MP4 file.
        do {
            assetWriter = try AVAssetWriter(outputURL: fileURL, fileType: .mp4)
        } catch {
            print("Error creating asset writer: \(error)")
            return
        }
        
        // Set up video input based on the screen size.
        #if os(iOS)
        let screenSize = UIScreen.main.bounds.size
        #else
        let screenSize = NSScreen.main?.frame.size ?? CGSize(width: 1920, height: 1080)
        #endif
        let videoSettings: [String: Any] = [
            AVVideoCodecKey: AVVideoCodecType.h264,
            AVVideoWidthKey: screenSize.width,
            AVVideoHeightKey: screenSize.height
        ]
        videoInput = AVAssetWriterInput(mediaType: .video, outputSettings: videoSettings)
        videoInput?.expectsMediaDataInRealTime = true
        if let videoInput = videoInput, assetWriter!.canAdd(videoInput) {
            assetWriter!.add(videoInput)
        }
        /*
        // Optionally, set up audio input.
        let audioSettings: [String: Any] = [
            AVFormatIDKey: kAudioFormatMPEG4AAC,
            AVNumberOfChannelsKey: 2,
            AVSampleRateKey: 44100,
            AVEncoderBitRateKey: 192000
        ]
        audioInput = AVAssetWriterInput(mediaType: .audio, outputSettings: audioSettings)
        audioInput?.expectsMediaDataInRealTime = true
        if let audioInput = audioInput, assetWriter!.canAdd(audioInput) {
            assetWriter!.add(audioInput)
        }
        */
        assetWriter?.startWriting()
        
        // Enable the microphone if needed.
        //RPScreenRecorder.shared().isMicrophoneEnabled = true
        
        // Start capturing sample buffers.
        RPScreenRecorder.shared().startCapture(handler: { [weak self] (sampleBuffer, sampleBufferType, error) in
            guard let self = self else { return }
            if let error = error {
                print("Capture error: \(error)")
                return
            }
            
            // Begin the session on receipt of the first buffer.
            if self.sessionAtSourceTime == nil {
                let time = CMSampleBufferGetPresentationTimeStamp(sampleBuffer)
                self.sessionAtSourceTime = time
                self.assetWriter?.startSession(atSourceTime: time)
            }
            
            switch sampleBufferType {
            case .video:
                if self.videoInput?.isReadyForMoreMediaData == true {
                    self.videoInput?.append(sampleBuffer)
                }
            case .audioMic:
                if self.audioInput?.isReadyForMoreMediaData == true {
                    self.audioInput?.append(sampleBuffer)
                }
            default:
                break
            }
        }, completionHandler: { error in
            if let error = error {
                print("Start capture error: \(error)")
            } else {
                self.filesCreated.append(fileURL)
            }
        })
    }
    
    func startRecording() {
        isSimpleCapture = true
        RPScreenRecorder.shared().startRecording() {error in
            if let error = error {
                print("Start capture error: \(error)")
            } else {
                print("Successful video handler")
            }            
        }
    }
    
    /// Stops recording and finalizes the video file.
    func stopRecording(completion: @escaping (RPPreviewViewController?) -> Void) {
        if isSimpleCapture {
            RPScreenRecorder.shared().stopRecording { (previewController, error) in
                if let error = error {
                    print("Error stopping recording: \(error.localizedDescription)")
                    completion(nil)
                } else {
                    completion(previewController)
                }
            }
            return
        }
        RPScreenRecorder.shared().stopCapture { [weak self] error in
            guard let self = self else { return }
            self.videoInput?.markAsFinished()
            self.audioInput?.markAsFinished()
            if let writer = self.assetWriter {
                self.assetWriter?.finishWriting {
                    completion(nil)
                }
            } else {
                completion(nil)  // if doing ReplayKit styles that don't have a writer
            }
        }
    }
}


extension ReplayKitRecorder: RPPreviewViewControllerDelegate {
    func previewControllerDidFinish(_ previewController: RPPreviewViewController) {
        //self.completion()
    }
}
